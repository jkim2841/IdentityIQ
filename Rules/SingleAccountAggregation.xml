<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<Rule language="beanshell"name="AD_AggregateSingleAccount" type="Workflow">
  <Description>A Workflow rule that Aggregates a single account</Description>
  <Source>
import sailpoint.object.Application;
import sailpoint.object.Attributes;
import sailpoint.object.Custom;
import sailpoint.object.Filter;
import sailpoint.object.Identity;
import sailpoint.object.Link;
import sailpoint.object.QueryOptions;
import sailpoint.object.ResourceObject;
import sailpoint.object.TaskResult;
import sailpoint.object.Rule;
import sailpoint.connector.JDBCConnector;
import sailpoint.api.Aggregator;
import sailpoint.connector.Connector;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;
 
 
/*
 * Define application name and account name below
 */
 
String applicationName = "";
String accountName = "";
 
 
 
// We have already validated all of the arguments.  No just load the objects.
Application appObject = context.getObjectByName(Application.class, applicationName);
String appConnName = appObject.getConnector();
String errorMessage = "";
log.debug("Application " + applicationName + " uses connector " + appConnName);
 
Connector appConnector = sailpoint.connector.ConnectorFactory.getConnector(appObject, null);
if (null == appConnector) {
   errorMessage = "Failed to construct an instance of connector [" + appConnName + "]";
   return errorMessage;
}
 
log.debug("Connector instantiated, calling getObject() to read account details...");
 
ResourceObject rObj = null;
try {
 	
   rObj = (ResourceObject) appConnector.getObject("account", accountName, null);
 	
} catch (sailpoint.connector.ObjectNotFoundException onfe) {
   errorMessage = "Connector could not find account: [" + accountName + "]";
   errorMessage += " in application  [" + applicationName + "]";
   log.error(errorMessage);
   log.error(onfe);	
   return errorMessage;
}
 
if (null == rObj) {
   errorMessage = "ERROR: Could not get ResourceObject for account: " + accountName;
   log.error(errorMessage);
   return errorMessage;
}
 
log.debug("Got raw resourceObject: " + rObj.toXml());
 
// Now we have a raw ResourceObject.  The Application in IdentityIQ may have a 
// Customization rule defined to transform the ResourceObject.  We need to 
// honor that configuration, so if the Applicaiton has a Rule then we run it.
Rule customizationRule = appObject.getCustomizationRule();
if (null != customizationRule) {
 
   log.debug("Customization rule found for applicaiton " + applicationName);	
 	
   try {
 	
  	// Pass the mandatory arguments to the Customization rule for the app.
  	HashMap ruleArgs = new HashMap();
  	ruleArgs.put("context", 	context);
  	ruleArgs.put("log",     	log);
  	ruleArgs.put("object",  	rObj);
  	ruleArgs.put("application", appObject);
  	ruleArgs.put("connector",   appConnector);
  	ruleArgs.put("state",   	new HashMap());
 	
  	// Call the customization rule just like a normal aggregation would.
  	ResourceObject newRObj = context.runRule(customizationRule, ruleArgs, null);
    	
  	// Make sure we got a valid resourceObject back from the rule.  
  	if (null != newRObj) {
     	rObj = newRObj;
     	log.debug("Got post-customization resourceObject: " + rObj.toXml());
  	} 	
    	
   } catch (Exception ex) {
 	
  	// Swallow any customization rule errors, the show must go on!
  	log.error("Error while running Customization rule for " + applicationName);
       	
   }  
 
}
 
// Next we perform a miniature "Aggregation" using IIQ's built in Aggregator.
// Create an arguments map for the aggregation task. 
// To change this (if you need to), the map contains aggregation options and is the same as the 
// arguments to the acocunt aggregation tasks.  Some suggestied defaults are:
 
  // ORIGINALLY all set to TRUE, turned to false for SAP TESTING
 
Attributes argMap = new Attributes();
 
//  argMap.put("promoteManagedAttributes",	"true");
argMap.put("promoteAttributes",   	"true");
argMap.put("deltaAggregation",   	"true");
argMap.put("correlateEntitlements",   "true");
argMap.put("noOptimizeReaggregation", "true");  // Note: Set to false to disable re-correlation.
argMap.put("correlateOnly", "false");
 
 
// Consturct an aggregator instance.
Aggregator agg = new Aggregator(context, argMap);
if (null == agg) {
   errorMessage = "Null Aggregator returned from constructor.  Unable to Aggregate!";
   log.error(errorMessage);
   return errorMessage;
}
 
// Invoke the aggregation task by calling the aggregate() method.
// Note: the aggregate() call may take serveral seconds to complete.
log.debug("Calling aggregate() method... ");
TaskResult taskResult = agg.aggregate(appObject, rObj);
log.debug("aggregation complete.");
 
if (null == taskResult) {
   errorMessage = "ERROR: Null taskResult returned from aggregate() call.";
   log.error(errorMessage);
   return errorMessage;
}
 
log.debug("TaskResult details: \n" + taskResult.toXml());
 
return ("Success");
</Source>
</Rule>

